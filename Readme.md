# General
This is the GitHub repository for the Drive Control Software developed for the Lab Course "HW/SW co-design of an autonomous car" @TUM in SS17.
In case you are not already on the GitHub page, you can find the online repo [here](https://github.com/DanielSel/iron-car-drive-control).
If you have any questions about our code or setup, please don't hesitate to ask. This is especially important for future teams that continue the work on the car ;)
Also, if you are tasked with further development of this software, feel free to fork this repository and contribute pull requests :)


# Setup
## Start-Up Procedure
* Make sure the battery is charged and connected to the ESC
* Press the small red power button that is attached to the frame of the car
* Wait for all components to initialize (couple of seconds)
* You can now use the remote control or the serial interface to control the car

## Controlling the Car
There are four ways to connect to the car from your computer and send control commands
1. Use the Webinterface running on the Raspberry PI
2. Use [USB-over-Network software](https://www.fabulatech.com/usb-over-network-download.html) to directly access the Arduino's serial interface through the Raspberry Pi
3. VNC into the Rasperry PI and launch the Serial Monitor remotely
4. Directly connect the Arduino board by disconnecting the USB-cable from the RPI and connecting it to your computer

### Webinterface on the Raspberry PI
* DISCLAIMER: This Website was developed by the team from the previous semester and does not access the whole functionality of the current drive control software
* Connect to the RPI's Wifi Hotspot (see Section [Raspberry PI](#raspberry-pi) below for details)
* Open http://10.42.0.1:5000 in your web browser
* Enter BOTH values, Motor and Steering Power (even if you don't want to change one of them)
* Press Submit

### USB-over-Network
* Go to [this website](https://www.fabulatech.com/usb-over-network-download.html), download the current version of the client software for your operating system and install it
* Connect to the RPI's Wifi Hotspot (see Section [Raspberry PI](#raspberry-pi) below for details)
* Run the USB-over-Network client
* Add the RPI IP Address as Server (see Section [Raspberry PI](#raspberry-pi) below for details)
* The USB Serial Interface should show up as shared device. Attach it and wait for you operating system to recognize it and install drivers
* See Section [Control via Serial Monitor](#control-via-serial-monitor) for further instructions

### VNC and Remote Serial Monitor
* Install any VNC client software suitable for your operating system (e.g. VNC Viewer)
* Connect to the RPI's Wifi Hotspot (see Section [Raspberry PI](#raspberry-pi) below for details)
* Start the VNC client and connect to the Raspberry's IP address
* You should either see the desktop or a login screen. If you see a login screen, enter the credentials from the RPI section below
* Start the Arduino IDE via shortcut from the desktop
* See Section [Control via Serial Monitor](#control-via-serial-monitor) for further instructions

### Direct Connection to Arduino Board
* NOTE: You shouldn't have to do this. Use this as a last resort, when there is something wrong with the RPI or wireless connection.
* NOTE: Make sure the USB ports on your computer have protection against overcurrent (Any kind-of-recent computer should have it). This might occur due to electricity flowing from the battery into your computer through the Arduino board
* Physically remove the USB cable that is connected to the Arduino from the Raspberry PI and attach it to your computer
* Put the car onto some box or similar object, so the wheels don't touch the ground. Otherwise, it may drive away and drag your computer with it in the case of a malfunction
* See Section [Control via Serial Monitor](#control-via-serial-monitor) for further instructions

### Control via Serial Monitor
* You need a software for monitoring and interacting with serial connections, e.g. Serial Monitor contained in the [Arudino IDE](https://www.arduino.cc/en/Main/Software)
* Start the Arduino IDE
* Select the correct device in Tools -> Port
* Start the Serial Monitor via Tools -> Serial Monitor
* In the Serial Monitor you can see the Output generated by the Car and you can send commands by typing them in the text bar at the top and pressing the Send button
* For further information on how to configure Log output and which commands are available, see Section [Serial Communication Protocol](#serial-communication-protocol) under Chapter [Documentation Notes](#documentation-notes)


## Raspberry PI
* Wifi Hotspot: IronCar
* Wifi Password: LegoCar!17
* RPI IP: 10.42.0.1
* Username: rpi
* Password: LegoCar!17
* Services running on RPI
    * SSH
    * VNC
    * USB-over-Network
* Special: You can find the source code for the drive control software currently deployed on the arduino on the RPI


# Documentation Notes:
## Wiring
### RC -> Arduino
GND -> GND (Black Cable [part of 3-pin connector])
5V -> 5V (Red Cable [part of 3-pin connector])
Servo (1CH) -> Pin D11 (White Cable [part of 3-pin connector])
Motor (2CH) -> Pin D12 (Yellow cable)

### Arduino -> Servo
Pin D09 -> Servo Input (Orange Cable)

### Arduino -> Motor
Pin D10 -> ESC (Green Cable)

### Raspberry PI -> Arduino
USB-to-Serial Interface

### Power Supply
ESC gets power from Battery and forwards to RC, which in turn forwards to Servo, Arduino and Raspberry PI via 3-pin connector.

## Serial Communication Protocol
* Basic Logging to Serial Channel. Configured in setup() method in main .ino file. Set Log Level as Desired. Possible Values: CRITICAL, ERROR, WARNING, INFO, DEBUG, TRACE.
    * NOTE: Only use DEBUG and TRACE if you are trying to find an error. Sending many messages over Serial greatly impacts performance and stability!
* Control Message Format: `<ControlCode`>:`<ControlValue`>;
    * Example: 1:1600; (Set Power of 1600 to Motor -> Slow Forward Movement)

### Table of Codes and Values:
Control Code    |    Min Value    |    Neutral Value    |    Max Value    |    Description
------------    |    ---------    |    -------------    |    ---------    |    -----------
0               |    0            |    0                |    0            |    Reset the Controller State -> Sets Motor and Servo back to Neutral.  Example: 0:0;
1               |    955          |    1500             |    2025         |    Set Power to MOTOR: < 1500 means Reverse. For Full Power Braking, send 955 while the car is moving forward. This will not damage the suspension. NOTE: Does not work when reversing. Do not try emergency braking by changing to full power forward while going reverse or you will DAMAGE THE CAR!
2               |    900          |    1500             |    2100         |    Set Steering Angle: Min = Full Left, Max = Full Right

## Input Control
* Reacts to Control Messages from User with 5Hz (every 200ms)
* Reacts to Remote Control with 50Hz (every 20ms)
* Obeys Input Control Messages over Serial Interface as long as there is no / neutral input signal from RC.
* If RC is used it overrides User Input until RC returns to neutral or RESET command is sent.

## Internal Details
* Uses Servo Library to generate 50Hz PWM Signal (Arduino's analogWrite generates a 590Hz signal)
* Uses EnableInterrupt Library for PinChangeInterrupts on RC Input Pins to decode the PWM Signal
* Currently NO input validation -> You can crash it by sending malformed command messages

## Limitations / TODO
* 8-bit PWM Signal (low resolution)
* Hall Sensors
* Ultrasonic

## Tips and Tricks
* Many librarys are bad implementations and cause lots of trouble. Do reasearch on libraries before using them and include as few as possible
* Think about architecture before starting to code. Remember to design your code to be easily maintainable and extensible
* Don't let tasks in loops run more often then necessary. Example: RC Input is a 50Hz PWM signal. Running the RC input task more than 20 times per second does not bring any extra performance, but costs ressources
* Serial Communication is very expensive. If you are sending a lot of debug messages, you might be causing the problem in the first place
* When implementing a new feature, write an extra sketch with a minimal implementation of only that feature first
* This arduino model used in the car allows only ONE interrupt on a PIN at the same time. Subsequent interrupt attachments will overwrite the previous ones
* If the battery is almost empty (or some device doesn't receive enough power for any reason), very strange things start to happen...


# Software Architecture and Build Environment

## Architecture
* All functionality is split into loosely coupled modules
* Initialization and Instantiation is done in the main file: DriveControl.Arduino.ino
* The workflow is based on Tasks and Interrupts
* Tasks are triggered by time based on a defined interval and continuously run repeatedly (see **Task** and **SerialInputControlTask**)
* The **loop** method of every active task should be executed in the Arduino's main **loop()** in DriveControl.Arduino.ino
* Interrupts are currently used to react to PWM input (see **ReadPwmInterrupt**)
* To add new functionality, one should add a new module based on one of the following three categories:
    * **Actuactors**
        * Manually triggered by code
        * Bound to (a) specific PIN(s)
        * Examples: MotorControl, SteeringControl
    * **Time-based or Polling input**
        * Continuously executed with a specified interval
        * Can be used for polling input channels
        * Extends the **Task** class and overrides the **execute()** method
        * Examples: SerialInputControlTask, Sensors (-> future work!)
    * **PWM Input**
        * Uses **ReadPwmInterrupt** to read a PWM value from a given input
        * Combined with a custom class to act on the calculated PWM value
        * The variable holding the PWM value should be declared **volatile** 
        * ReadPwmInterrupts are specified in DriveControl.Arduino.ino
        * Examples: ReadPwmInterrupt, RcInputControlTask
* Libraries are imported twice: In the main file and in every header file where they are used. This is due to differences between Arduino IDE and vMicro in resolving includes

### DriveControl.Arduino.ino
* All initialization and setup
* LogLevel is defined in the setup() method
* PINs are assigned to their respective processing modules (-> adapt after rewiring)
* Interrupts are attached and time-based tasks are executed in the loop() method

### Serial Interface
* Provides abstractions for serial communication
    * Initialization of the serial interface
    * Check if a message is available on the serial interface
    * Read control messages

### Logger
* Defines available Log Levels and Channels
    * Currently only supports Serial Interface as logging channel
* Provides abstractions for logging to different stages
* Simple extendibility in case future work wants to introduce other logging channels (central collection, log files, etc.)

### Task
* Abstract super-class for all time-based activities
* Loop method should be called from Arduino's main loop and requires the current time as parameter
* Executes the **execute()** method defined by the respective subclass in a given interval by comparing current time with last execution time

### SerialInputControlTask
* Execution Interval: 200ms
* Reacts to input on the serial channel
* Tries to interpret input as control messages
* Forwards decoded input values to the respective modules if there is no override active (only exception: reset command is always executed)

### ReadPwmInterrupt
* Binds to a single PIN and requires a pointer to a volatile variable
* Reacts to RISING and FALLING edges using Interrupts and automatic PIN detection
* Calculates the PWM value by measuring time between RISING and FALLING edges and storing it in the given variable

### RcInputControlTask
* Execution Interval: 20ms (=50Hz), because the signals from the RC are 50 Hz PWM
* Relies on ReadPwmInterrupt to provide the current PWM values for the motor and steering signals from the remote control
* Sanity checks input signals and goes into error state if RC is acting weird (has to be manually reset using the reset command)
* Checks for no or neutral signal from RC using thresholds
* Notify InputController about override and forward incoming signals from the RC if the values exceed the thresholds (which means they are not neutral, therefore a human is actively using the remote control)

### InputController
* Connection Point for multiple input providers
* Coordination of conflicting inputs
* Sets override on SerialInputControlTask if there is an active input from the RcInputControlTask
* Resets all input providers on execution of reset command

### MotorControl and SteeringControl
* Provide a method to set the PWM value that is output to the respective motor
* Sanity-checks the requested value and limits it to the allowed minimum and maximum values respectively

## Build
The software was developed using Visual Studio 2017 with the vMicro extension. Most deployments were however done using the Arduino IDE as it is more reliable in this matter. Hint: Don't enable the vMicro debugger, it causes weird runtime issues...

## Demo
There is a separate demo branch with an extra task. This extra task makes the car drive slowly in a circle and can be executed using command 9:1; (Left Circle) or 9:2; (Right Circle).